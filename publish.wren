import "wrun/process" for Shell, Process
import "wrun/file" for File
import "wrun/args" for Args
import "wrun/print" for Log

class Publisher {
  static run() {
    // Setup colored log levels for each fiber
    Log.addLevel("deploy", "blue")
    Log.addLevel("readme", "magenta")

    // 1. Check if this is a git repository
    if (!File.isDirectory(".git")) {
      Log.error("Not a git repository.")
      Process.exit(1)
    }

    // 2. Determine Repo Name
    var repoName = Args.count() > 0 ? Args.get(0) : Process.cwd().split("/")[-1]
    var domain = "%(repoName).stardive.live"

    Log.info("Starting parallel deployment", {"project": repoName})

    // Create the three fibers
    var readmeFiber = Fiber.new { generateReadme() }
    var mainFiber = Fiber.new { runDeployment(repoName, domain) }
    var coordinatorFiber = Fiber.new { coordinate(readmeFiber, mainFiber) }

    // Start the coordinator
    coordinatorFiber.call()
  }

  static coordinate(readmeFiber, mainFiber) {
    // Start README generation
    Log.info("Starting README generation")
    readmeFiber.call()

    // README fiber has yielded (committed README, waiting to push)
    // Start main deployment
    Log.info("Starting deployment")
    mainFiber.call()

    // Main deployment is done, resume readme to push
    Log.info("Pushing README commit")
    readmeFiber.transfer()
  }

  static runDeployment(repoName, domain) {
    // GitHub: Create repo and push
    Log.info("Creating/Pushing to GitHub", {"step": "1/3", "repo": repoName})
    var ghStatus = Shell.exec("gh repo create %(repoName) --public --source=. --push")

    if (ghStatus != 0) {
      Log.warn("GitHub step encountered an issue (repo might already exist)")
    } else {
      Log.custom("deploy", "GitHub repository created and pushed")
    }

    // Vercel: Deploy to production
    Log.info("Deploying to Vercel", {"step": "2/3"})
    var vercelStatus = Shell.exec("vercel --prod --yes")

    if (vercelStatus != 0) {
      Log.error("Vercel deployment failed")
      Fiber.abort("Vercel deployment failed")
    }

    Log.custom("deploy", "Vercel deployment successful")

    // Vercel: Assign Custom Domain
    Log.info("Assigning domain", {"step": "3/3", "domain": domain})
    var domainStatus = Shell.exec("vercel domains add %(domain)")

    if (domainStatus == 0) {
      Log.custom("deploy", "Project live at https://%(domain)")
    } else {
      Log.warn("Deployment succeeded, but domain assignment failed")
      Log.warn("Check if stardive.live is configured in your Vercel team/account")
    }
  }

  static generateReadme() {
    Log.info("Generating README with Claude...")

    var readmeContent = runClaudeForReadme()

    if (readmeContent != null && readmeContent != "") {
      // Write README.md
      if (File.write("README.md", readmeContent)) {
        Log.custom("readme", "README.md written successfully")

        // Commit README
        var commitStatus = Shell.exec("git add README.md && git commit -m \"Add README (generated by Claude)\"")

        if (commitStatus != 0) {
          Log.warn("Could not commit README (may already exist or no changes)")
        } else {
          Log.custom("readme", "README committed")
        }
      } else {
        Log.warn("Failed to write README.md")
      }
    } else {
      Log.warn("No content generated, skipping")
    }

    // Signal that we're done with readme work, wait for deployment to finish
    Fiber.yield()

    // Push README commit (reached via transfer from coordinator)
    var pushStatus = Shell.exec("git push")

    if (pushStatus == 0) {
      Log.custom("readme", "README commit pushed successfully")
    } else {
      Log.warn("Failed to push README commit")
    }
  }

  static runClaudeForReadme() {
    var prompt = "Analyze project files to determine if this is a CLI, Web App, Library, or other type. Generate a README.md following a 'Modern/Polished' style adapted to the type. Output ONLY raw markdown (no conversational text/code blocks).\\n\\nStructure requirements:\\n1. Header: H1 Title, right-aligned icon (~120px), status badges (last commit, visitors) below title.\\n2. Description: H4 functional description, followed by a witty/technical tagline in italics.\\n3. 'Made with' section: Badges for Language, Registry version, key dependencies.\\n4. Visuals: Hero Image/GIF placeholder. For Web: Screenshot placeholders. For CLI: Terminal demo placeholder. Use <details><summary> for extra screenshots.\\n5. Setup/Usage: Clear code blocks. For CLI: Install & Run commands, --help output. For Web: Local dev setup, Deployment links. For Lib: Installation & Code example.\\n6. Roadmap: Nested checklists for features.\\n7. Technical Insights: Mermaid flowchart for core logic/architecture.\\n8. Tone: Conversational, honest (1st person voice), technical but casual. Acknowledge trade-offs explicitly.\\n\\nEnsure the content accurately reflects the codebase found in the current directory."
    
    var cmd = "claude -p --output-format text --permission-mode default \"%(prompt)\""

    if (Shell.run(cmd)) {
      return Shell.stdout
    } else {
      Log.warn("Claude generation failed", {"error": Shell.stderr})
      return null
    }
  }
}

Publisher.run()
