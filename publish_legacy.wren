import "wrun/process" for Shell, Process
import "wrun/file" for File
import "wrun/args" for Args
import "wrun/print" for Log

class Publisher {
  static run() {
    Log.addLevel("deploy", "blue")
    Log.addLevel("readme", "magenta")

    if (!File.isDirectory(".git")) {
      Log.error("Not a git repository.")
      Process.exit(1)
    }

    var repoName = Args.count() > 0 ? Args.get(0) : Process.cwd().split("/")[-1]
    var domain = "%(repoName).stardive.live"

    Log.info("Starting parallel deployment", {"project": repoName})

    // Spawn both tasks in parallel using async processes
    var readmeHandle = Shell.spawnAsync("claude -p --output-format text --permission-mode default \"Analyze project files to determine if this is a CLI, Web App, Library, or other type. Generate a README.md following a 'Modern/Polished' style adapted to the type. Output ONLY raw markdown (no conversational text/code blocks).\"")
    
    var ghHandle = Shell.spawnAsync("gh repo create %(repoName) --public --source=. --push")

    if (readmeHandle == 0) {
      Log.warn("Failed to spawn README generation")
    } else {
      Log.info("README generation started (async)")
    }

    if (ghHandle == 0) {
      Log.warn("Failed to spawn GitHub creation")
    } else {
      Log.info("GitHub repo creation started (async)")
    }

    // Poll until both are done
    var readmeDone = readmeHandle == 0
    var ghDone = ghHandle == 0

    while (!readmeDone || !ghDone) {
      if (!readmeDone && Shell.isDone(readmeHandle)) {
        readmeDone = true
        var code = Shell.getExitCode(readmeHandle)
        if (code == 0) {
          var content = Shell.getStdout(readmeHandle)
          if (content != "" && File.write("README.md", content)) {
            Log.custom("readme", "README.md written successfully")
            Shell.exec("git add README.md && git commit -m \"Add README (generated by Claude)\"")
          }
        } else {
          Log.warn("README generation failed", {"stderr": Shell.getStderr(readmeHandle)})
        }
        Shell.cleanup(readmeHandle)
      }

      if (!ghDone && Shell.isDone(ghHandle)) {
        ghDone = true
        var code = Shell.getExitCode(ghHandle)
        if (code == 0) {
          Log.custom("deploy", "GitHub repository created and pushed")
        } else {
          Log.warn("GitHub step encountered an issue (repo might already exist)")
        }
        Shell.cleanup(ghHandle)
      }

      // Small sleep to avoid busy-waiting (using a no-op command)
      if (!readmeDone || !ghDone) {
        Shell.exec("sleep 0.1")
      }
    }

    // Now do Vercel deployment (sequential, needs GitHub first)
    Log.info("Deploying to Vercel")
    var vercelStatus = Shell.exec("vercel --prod --yes")

    if (vercelStatus != 0) {
      Log.error("Vercel deployment failed")
      Process.exit(1)
    }

    Log.custom("deploy", "Vercel deployment successful")

    // Assign domain
    Log.info("Assigning domain", {"domain": domain})
    var domainStatus = Shell.exec("vercel domains add %(domain)")

    if (domainStatus == 0) {
      Log.custom("deploy", "Project live at https://%(domain)")
    } else {
      Log.warn("Deployment succeeded, but domain assignment failed")
    }

    // Push README commit if it was created
    Shell.exec("git push")
    Log.info("Done!")
  }
}

Publisher.run()
